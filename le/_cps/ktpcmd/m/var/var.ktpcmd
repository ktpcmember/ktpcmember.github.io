<meta>
title += "変数基礎 - C++ on MSVC講習"
keywords += ", C++, MSVC"
description = "C++の組み込み型とstd::stringについて解説しています。"
</meta>

<header>
name = "C++ on MSVC講習"
top = "le\_cps\_cps.html"
index = "le\_cps\m\i_dx\i_dx.html"
before = "le\_cps\ktpcmd\m\hello\hello.html"
next = ""
</header>

<main>
# C++ on MSVC講習/変数基礎

## あらすじ
前回は、Hello World!プログラムを通じて、基本的なコードの決まりを解説しました。
また、標準出力やリテラルを使い、コンソールへ単純な文字列を出力できるようになりました。

*- 重要語
*+ 必要語

## C++の変数
変数って、何なんでしょうか。ひとまず解説するので一読してみてください。
一読したら、進んでみて、また分からなくなったら読んでみてくださいね。

### リテラルだと不便なところ
前回のコードHello World!では、リテラルを使っていました。
それでは、同じ値でも複数の文で使用するには、**その度に書かなくては**いけません。
他にも、**実行時に値を決定したり、変更**したりすることが出来ません。
前回のプログラムだと、表示する内容を変えるごとにコンパイルしないといけません。

### 値を保存すればいいのよ
それらは、**実行時に値を保存・変更できる仕組み**があれば解決することが出来ます。
その仕組みが変数で、**名前に値を関連付ける**ことで値を保存することが出来るようになります。

### 型
C++の変数は、必ず型を持っていて、**型によってコードでの振る舞いが制限**されています。
そして、型による振る舞いの制限が守られているか**コンパイル時にチェック**されます。
それによって、プログラマーの**ミスを実行前に発見し、修正**することが出来るのです。
ですから多くの場合、型には、意味論としての使用法や性質が名前として付けられます。

### 型の種類
ライブラリ等が必要ない、C++に元から組み込まれている型を**組み込み型**と総称します。
一方、ライブラリ等で型の定義を導入できるものを**ユーザー定義型**と総称します。
今回は組み込み型から、**整数だけを扱える`int`**と、**小数まで扱える`double`**を、
ユーザー定義型からは、**文字列を扱う為の`std::string`**について解説します。

## 整数を扱おう
まずは整数を扱ってみましょう。次のコードをコピペして実行しましょう。

```cpp 整数
#include <iostream>

int main() {
	//符号あり（負数が使える）
	signed short int        a;
	signed int              b = 10;
	signed long int         c(20);
	signed long long int    d{ 40 };

	// 初期化されていない「a」は、値が不定なので使用してはいけない

	a = 1; // 「a」に1を代入

	// 代入された「a」は、代入された値になったので、使用してよい

	std::cout << "a : " << a << "\n"
		<< "b : " << b << "\n"
		<< "c : " << c << "\n"
		<< "d : " << d << "\n\n";


	// 符号なし（負数が使えない）
	unsigned u_a = 1, u_b(10), u_c{ 20 }, u_d = { 40 };

	std::cout << "u_a : " << u_a << "\n"
		<< "u_b : " << u_b << "\n"
		<< "u_c : " << u_c << "\n"
		<< "u_d : " << u_d << "\n";
}
```

```cmd 実行結果
< a : -1
< b : -10
< c : -20
< d : -40
<
< u_a : 1
< u_b : 10
< u_c : 20
< u_d : 40
<
```

## 解説
さて、コードの解説に入っていきます。

### 宣言
変数は**「名前に値を関連付けることで値を保存」**出来ると説明しました。
そのためには、まず**コンパイラに変数を使うことを教える**必要があります。
それを**宣言（文）**といい、必要な所を単純化すると、以下のような構文になります。
宣言子で宣言子が出るのは、`識別子 初期化子(opt)`を`,`並びで書ける為です。

*- 追加される構文の記法
- なにかしら(opt) 省略可能（例だと、「なにかしら」を省略可能）

```syntax 変数宣言
型名 宣言子 `;`
```

```syntax 宣言子
識別子 初期化子(opt)
宣言子 `,` 識別子 初期化子(opt)
```

### 整数を扱う型
整数を扱う型は、**組み込み型の1つである`[int](いんと)`**です。
**[signed](さいんど)/[unsigned](あんさいんど)**で**符号のあり/なし**、即ち**負の数が扱えない/る**を、
**[short](しょーと)/[long](ろんぐ)/[long long](ろんぐろんぐ)**で**変数のサイズ**を指定することが出来ます。
サイズについてはコード解説が終わった後に解説します。

*- 主な整数を扱う型と別名
- {short int} {short/signed short/signed short int}
- {int} {signed/signed int}
- {long int} {long/signed long/signed long int}
- {long long int} {long long/signed long long/signed long long int}
- {unsigned short int} {unsigned short}
- {unsigned int} {unsigned}
- {unsigned long int} {unsigned long}
- {unsigned long long int} {unsigned long long}

### 初期化
宣言すると同時に、**値を設定**しましょう。**それが初期化です**。
大雑把に説明すると、下3つは、**値を省略すると`0`で初期化**され、
特に、下2つは、値が**変数で表せない値であるかのチェック**がされます。

```syntax 初期化子
`=` 値
`(` 値(opt) `)`
`{` 値(opt) `}`
`=` `{` 値(opt) `}`
```

### 初期化してない組み込み型
初期化を**しなかった**組み込み型の変数は、**その持つ値は不定になります**。
この不定の値を持つ組み込み型の変数は、**その値を使うことはしてはいけません**。
その様な変数を使って良い状態になるのは、**代入等で値を設定してから**です。
**コンパイルエラーは出ません**が、標準規格で**未定義動作とされる状態になります**。
未定義動作は、タイムトラベルしたり鼻から悪魔が出るので、起こしてはいけません。

### 代入
初期化したしないに関わらず、**宣言後に値を変更するときは代入式**を使用します。
**左辺には変数**、**演算子は`=`**、**右辺には値**（変数も大丈夫）を書きます。
すると、**右辺の値を左辺に設定する働き**をします。**数学的なイコールとは違います**。
**代入は式**なので、**最後に`;`を付けて文にしないと存在できない**ことに注意しましょう。
構文は以下のようになります。2つ目の挙動は初期化のものとほぼ同じです。

```syntax 代入
変数 `=` 値
変数 `=` `{` 値(opt) `}`
```

## 整数の内部表現
変数のサイズとは何のことでしょうか。それにはまず、コンピューターでの内部表現を知りましょう。
また、丁度いいので、整数の内部表現についても解説していきます。
正直コードを理解するのに必要は無いので、必要になったら読むのでもいいでしょう。

### ビットとバイト
コンピューターでは、**電気的なOn/Offで1/0を表現し、2進数として**扱っています。
最小となる、その**1/0を表現する単位をビット**、そして**8[bit](ビット)でバイト**と扱われます。
なお、8bitで1[Byte](バイト)とは**決まっているわけでは無く**、そうでない場合も極々稀にあります。

### 変数のサイズ
変数のサイズというのは、即ち**変数が使うビットの量**のことになります。
ただし、ビットは物理的に存在している以上、無限に存在しているわけではありません。
また、変数のサイズは固定されていると何かと便利ですし、効率がよくなります。
以上のことから、**変数にサイズを決める、あるいは決まってしまう**のが普通です。

### 負の数を扱いたくなりました
**負の数を扱いたくなりました**。この時一番簡単に思いつくのは**符号ビットを使う**ことです。
例えば、8bitの整数があった時、`**[0](これ)**000 0000`を符号ビットということにしてみましょう。
符号ビットが**`0`/`1`の時、正/負**とし、**残り7bitは絶対値で表現**してみましょう。
`[0000 0001](1)`に対して、`[1000 0001](-1)`のようになり、**`-127から127`が表現できます**。

### 1の補数表現
符号ビットと絶対値で表す以外にも、**正の数の表現を[ビット反転](各ビットの0と1を逆にする)する方法**もあります。
例えば、上と同じく8bitの整数で、`[0000 0001](1)`をビット反転して`[1111 1110](-1)`といった具合。
これも**やっぱり`-127から127`まで表現でき**、`**[0](これ)**000 0000`は**符号ビットの役割を果たします**。
これは、数学の「補数」という考え方に由来するため、**1の補数表現**と言います。

### ダメなのよ。
上の2つの表現、**実はどっちもダメ**なところがあります。例えば、**`0`が2種類ある**のです。
1つの数値に対して2つ以上表現があると、**一意に表現できていない**ということになるのです。
でも、符号ビットが`1`の時は`0`を表現しない、とすると**表現が1個捨てられて無駄**です。

### 2の補数表現
どうすればいいのか。人類はやっぱり数学に由来して、**2の補数表現**にたどり着きました。
内容としては、**負の数は、1の補数表現に`+1`をした表現**で表すことにしたのです。
つまり、8bitの`-1`なら、`[0000 0001](1)`→`[1111 1110](1の補数の-1)`→`[1111 1111](2の補数の-1)`ということになりました。
これなら、例えば8bitであれば、**`127から-128`までを表せる**のです。
また、これも1Byte=8bitのくだりと同じく、ごく稀にそうでない処理系もあります。

### 何がいいのさ
さて、ここまで斜め読みした人は、**どうしてこんな面倒なことをしたんだろう**と思うでしょう。
実は、2の補数表現は**減算を乗算で処理できる**という真の力を秘めているのです。
`36-12→24`なら、`12`を`-12`にして足すと`[0010 0100](36) + [1111 0100](-12) → [0001 1000](24)`、**あらあら**。
**桁あふれした分は見なかったこと**にして、**2進法で計算すると減算が加算で処理できる**のです。

## 小数を扱おう
次は小数を扱ってみましょう。次のコードをコピペして実行しましょう。

```cpp 小数
#include <iostream>
#include <iomanip>

int main() {
	float f;
	double d = .1;
	long double ld = 1234e-5;

	f = 2.345;

	std::cout << std::fixed << std::setprecision(10)
		<< "f  : " << f << "\n"
		<< "d  : " << d << "\n"
		<< "ld : " << ld << "\n\n";
}
```

```cmd 実行結果例
< f  : 2.3450000286
< d  : 0.1000000000
< ld : 0.0123400000
<
```

### 実行結果例補足
代入値と異なる表示になる場合があります。
が、それは生じてしまう誤差なので気にしない方針にしてください。

## 解説
コードの解説をします。

### 概説
小数を扱える型は、**`[float](ふろーと)`と`[double](だぶる)`と`[long double](ろんぐだぶる)`**があります。
これらは、左よりは右の方が**より誤差無く表せる値の範囲が大きい、又は同様**になります。
ただし、宣言と初期化、代入についての文法は、整数と同様なので飛ばします。
もちろん、整数と同様に、**初期化をしないと不定な値を持ち、それを使用してはいけません**。

### 小数リテラル
前回軽く取り上げた小数リテラルですが、**指数表記**も用いることが出来ます。
指数表記は、`[1.2e5](1.2×10^5=120000)`や`[-1.2e-5](-1.2×10^-5=-0.000012)`など、**仮数+基数の指数乗で表現**する表記法です。
通常、`[1.2×10^5](1.2×10^5=120000)`などと基数を書きますが、**`E`や`e`が`10`として用いられる事があります**。
また、通常の表記法でも、**整数部分や小数部分がない場合、省略**することも出来ます。

### std::coutとマニピュレータ
`std::cout`、実は**出力を少し変化させる**ことが出来、その時に使うのが**マニピュレータ**です。
マニピュレータを使う時には、**main関数の前に`#include <iomanip>`と書きます**。
小数を表示するときには、**`std::fixed`と`std::setprecision`**が便利です。
**先に`std::fixed`を出力し、次に`std::setprecision(自然数)`として出力**します。
すると、**小数点以下の出力桁数が`std::setprecision`の括弧の中に書いた値**になります。

浮動小数点数の内部表現
コンピューターでは小数を、**浮動小数点数**という形式で表現されることが多いです。
これは、**誤差を許容する**代わりに、**極端に大きい/小さい値を表現できる**ものです。
多くのコンピューターでは、浮動小数点数を**[IEEE](あいとりぷるいー) 754**という規格に従って実装しています。
ですから、IEEE 754の仕様を簡単に解説します。

## 文字列を扱おう
ひとまず最後に文字列を扱いましょう。

```cpp 文字列
#include <iostream>
#include <string>

int main() {
	std::string s1 = "namanegi",
		s2("namagoe"),
		s3{ "namahatsune" },
		s4 = { "mikudayo-" };

	std::cout << "s1 : " << s1 
		<< "\ns2 : " << s2 
		<< "\ns3 : " << s3 
		<< "\ns4 : " << s4 << "\n";
}
```

```cmd 実行結果
< s1 : namanegi
< s2 : namagoe
< s3 : namahatsune
< s4 : mikudayo-
<
```

## 解説
それでは解説です。

### 文字の表現
例によってコンピューターでは文字を直接表現することは出来ません。
なので、**文字1つ1つに一意な番号をつけ**、**それを符号化**することで表現しています。
また、**文字とその番号、そしてそれの符号化形式を定めたものを文字コード**と呼びます。
なお、符号化は、あるデータを**コンピューターで表せるような形式にする**ことを指します。

### 文字列の表現
文字列は、当然文字の列ですから、変数で扱うときは**1つの整数に収まる筈はありません**。
**沢山変数を並べた物を1つの変数として扱う**必要があり、それを実現する機能が**配列**です。
文字列は配列を使って表現されますが、難しいので**標準ライブラリを使いましょう**。

### <string>とstd::string
使う標準ライブラリは`string`です。**`#include <string>`をmain関数の前に書きましょう**。
**文字列を扱うために作られた、`std::string`という型**が使用できるようになります。
`std::stirng`は、**ユーザー定義型ですから、型の定義を`string`から導入**しないといけません。

### 組み込み型と違う所
宣言と代入は組み込み型と同様ですが、初期化はユーザー定義型であるので、少し異なります。
丸括弧や波括弧を使った初期化の場合、**`,`区切りの値の並びを取ることがあります**。
ただし、これは**型での定義次第**なので、特になにも取らないときもあります。
詳しくは、**ユーザー定義型の定義方法の1つ、クラス**を扱うときに同時に扱います。

## 入力
さて、変数をやったので、実行時に値を決める手頃な手段の入力をしましょう。
標準出力の逆で、標準入力から値を取得しましょう。

```cpp 入力
#include <iostream>
#include <string>

int main() {
	int i;
	double d;
	std::string s, t;

	std::cin >> i >> d >> s >> t;

	std::cout << "i : " << i
		<< "\nd : " << d
		<< "\nts: " << t << s;
}
```

### 入力例
コンソールに、今度は入力する必要があるので、入力も含めて実行結果例を書きます。
MSVCでは、標準では1つのコンソールに入出力をするので、混ざることがあります。
また、今後は入力に`> `を、出力に`< `を先頭に追加して表記していきます。

```cmd 実行結果例
> 10 0.34 dayo- miku
< i : 10
< d : 0.34
< ts: mikudayo-
```

```cmd 実行結果例
> 10
> 0.34
> dayo-
> miku
< i : 10
< d : 0.34
< ts: mikudayo-
```

## 解説
もう少し面白くなってきたと思います。

### 標準入力とstd::[cin](しーいん)
標準出力の逆です。コンソールから数字や文字列を入力することが出来ます。
`std::cin`から入力する時に使う演算子も逆で、`>>`を使用します。
変数`s`と`t`のように、文字列の場合は半角スペースや改行で区切られて入力されます。

## 練習問題
今回はAPG4bという、AtCoder社のC++教材の問題も解いてみましょう。
AtCoder社は、プログラミングで問題を解くオンラインゲームを提供しています。
詳しくは、[AtCoderとは - 競技プログラミング講習 - 駒場東邦物理部].{le/k_c_pej_p_gm/about/about.html}を参照してください。
AtCoderへの登録を済ませていた場合、AtCoderの問題ページ下から提出が出来ます。
GCCを選んで提出し、ACと出れば正解、CEならコンパイルエラー、WAなら不正解です。

### その1-問題文
空白区切りの文字列`S`,`T`の入力に対して、`T`、`S`の順でくっつけて出力してください。
入力例は便宜的にまとめています。空行の上と下でそれぞれ入力、出力だと思って下さい。

```cmd 入力
> S T
```

``` 入力例と出力例
> oumu watashiha

< watashihaoumu
```

@``cpp 回答例
#include <iostream>
#include <string>

int main() {
	std::string s;
	std::string t;

	std::cin >> s >> t;
	std::cout << t << s;
}
```

### その2-問題文
2つの整数`A`,`B`が以下のように与えられます。`A+B`の結果と改行を出力してください。
出典：[EX5 - A足すB問題]{https://atcoder.jp/contests/apg4b/tasks/APG4b_cr}

```cmd 入力
> A B
```

``` 制約
0 <= A,B <= 100
```

```cmd 入力例と出力例
> 1 2

< 3
```

@``cpp 回答例
#include <iostream>

int main() {
	int a;
	int b;

	std::cin >> a >> b;

	std::cout << a + b << "\n";
}
```

## 文字コード物語
文字を表すのは大変なんだ、という話をします。
この段落は私情が入った言い回しをしていますがお察しください。

### [ASCII](あすきー)
まず**ほとんどの符号化形式の元となっている**のが、**ASCII**と呼ばれる文字コードです。
ASCIIでは、`0-127`の範囲に基本的な文字を割り当て、それを7bit以上の整数で符号化します。
実際の対応表は、[ASCII - Wikipedia]{https://ja.wikipedia.org/wiki/ASCII}を確認してください。

### 悪夢の始まり
ASCIIの成立後、ASCIIが使用しない範囲に文字を割り当てた**文字コードが乱立しました**。
**地域ごとに文字コードが存在**し、文字コードを**切り替えたりする**必要があるのです。
これは、**データの置き場たるメモリ**が、今のPC程**潤沢でない**ことが理由していました。
日本語Windowsでは**現在に至るまで**、Shift-JISの亜種Windows-31Jが使われています。

### 悪夢の終わりかのように見えた
そうして乱立した文字コードの波に飲まれ、疲弊してしていたプログラマ達[要検証]。
そこに現れたのは、**世界中の全ての文字を一つの文字コードにしようとした[Unicode](ゆにこーど)**。
Unicodeは元々、**世界の文字を[16bit](65536文字)に収めよう**として作られ、様々模索されました。
しかし、世界の文字が**16bitに収まる筈もなく、それらの模索は負債と化しました**。

### 現在
さて、Unicodeが普及し、**事無き事を得たように思えますが、そうでもありません**。
現在のUnicodeでは、UTF-8、UTF-16、UTF-32という符号化形式が使われていますが、
日本語Windowsでは、未だにWindows-31Jが標準で、UTF-8のサポートはまだまだです。
C+においても、Unicode対応が杜撰であることは広く知られています。
互換性等様々な壁があることは確かなので、一概に言える話では無いのですが。

</main>
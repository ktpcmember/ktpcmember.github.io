<meta>
title += "変数基礎 - C++ on MSVC講習"
keywords += ", C++, MSVC"
description = "C++の組み込み型とstd::stringについて解説しています。"
</meta>

<header>
name = "C++ on MSVC講習"
top = "le\_cps\_cps.html"
index = "le\_cps\m\i_dx\i_dx.html"
before = "le\_cps\ktpcmd\m\hello\hello.html"
next = ""
</header>

<main>
# C++ on MSVC講習/変数基礎

## あらすじ
前回は、Hello World!プログラムを通じて、基本的なコードの決まりを解説しました。
また、標準出力やリテラルを使い、コンソールへ単純な文字列を出力できるようになりました。

*- 重要語
*+ 必要語

## C++の変数
変数って、何なんでしょうか。ひとまず解説するので一読してみてください。
一読したら、進んでみて、また分からなくなったら読んでみてくださいね。

### リテラルだと不便なところ
前回のコードHello World!では、リテラルを使っていました。
それでは、同じ値でも複数の文で使用するには、**その度に書かなくては**いけません。
他にも、**実行時に値を決定したり、変更**したりすることが出来ません。
前回のプログラムだと、表示する内容を変えるごとにコンパイルしないといけません。

### 値を保存すればいいのよ
それらは、**実行時に値を保存・変更できる仕組み**があれば解決することが出来ます。
その仕組みが変数で、**名前に値を関連付ける**ことで値を保存することが出来るようになります。

### 型
C++の変数は、必ず型を持っていて、**型によってコードでの振る舞いが制限**されています。
そして、型による振る舞いの制限が守られているか**コンパイル時にチェック**されます。
それによって、プログラマーの**ミスを実行前に発見し、修正**することが出来るのです。
ですから多くの場合、型には、意味論としての使用法や性質が名前として付けられます。

### 型の種類
ライブラリ等が必要ない、C++に元から組み込まれている型を**組み込み型**と総称します。
一方、ライブラリ等で型の定義を導入できるものを**ユーザー定義型**と総称します。
今回は組み込み型から、**整数だけを扱える`int`**と、**小数まで扱える`double`を、
ユーザー定義型からは、**文字列を扱う為の`std::string`について解説します。

## 整数を扱おう
まずは整数を扱ってみましょう。次のコードをコピペして実行しましょう。

```cpp 整数
#include <iostream>

int main() {
	// 符号付き（負数も使える）
	// 最長名                           // 普通使われる名前
	signed short int        a;          // short
	signed int              b = 10;     // int
	signed long int         c(20);      // long
	signed long long int    d{ 40 };    // long long

	// 初期化されていない「a」は、値が不定なので使用してはいけない

	// 「a」に1を代入
	a = 1;

	// 代入された「a」は、代入された値になったので、使用してよい

	std::cout << "a : " << a << '\n'
		<< "b : " << b << '\n'
		<< "c : " << c << '\n'
		<< "d : " << d << "\n\n";

	// 符号なし（負数は使えない）
	// 最長名                             // 通常使われる名前
	unsigned short int      u_a = 1;      // unsigned short
	unsigned int            u_b(10);      // unsigned
	unsigned long int       u_c{ 20 };    // unsigned long
	unsigned long long int  u_d = { 40 }; // unsigned long long

	std::cout << "u_a : " << u_a << '\n'
		<< "u_b : " << u_b << '\n'
		<< "u_c : " << u_c << '\n'
		<< "u_d : " << u_d << '\n';
}
```

```cmd 実行結果
> a : -1
> b : -10
> c : -20
> d : -40
>
> u_a : 1
> u_b : 10
> u_c : 20
> u_d : 40 
```

## 解説
さて、コードの解説に入っていきます。

### 宣言
変数は**「名前に値を関連付けることで値を保存」**出来ると説明しました。
そのためには、まず**コンパイラに変数を使うことを教える**必要があります。
それを**宣言**といい、以下のような構文を用いります。

*- 追加される構文の記法
- なにかしら(opt) 省略可能（例だと、「なにかしら」を省略可能）

```syntax 変数宣言
型名 識別子 初期化子(opt) `;`
```

### 整数を扱う型
整数を扱う型は、**組み込み型の1つである`int`**です。
**signed/unsigned**で**符号のあり/なし**、即ち**負の数が扱えない/る**を、
**short/long/long long**で**変数のサイズ**を指定することが出来ます。
サイズについてはコード解説が終わった後に解説します。

*- 主な整数を扱う型と別名
- {short int} {short/signed short/signed short int}
- {int} {signed/signed int}
- {long int} {long/signed long/signed long int}
- {long long int} {long long/signed long long/signed long long int}
- {unsigned short int} {unsigned short}
- {unsigned int} {unsigned}
- {unsigned long int} {unsigned long}
- {unsigned long long int} {unsigned long long}

### 初期化
宣言すると同時に、**値を設定**しましょう。**それが初期化です**。
大雑把に説明すると、下3つは、**値を省略すると`0`で初期化**され、
特に、下2つは、値が**変数で表せない値であるかのチェック**がされます。

```syntax 初期化子
`=` 値
`(` 値(opt) `)`
`{` 値(opt) `}`
`=` `{` 値(opt) `}`
```

### 代入
初期化したしないに関わらず、**宣言後に値を変更するときは代入式**を使用します。
**左辺には変数**、**演算子は`=`**、**右辺には値**（変数も大丈夫）を書きます。
すると、**右辺の値を左辺に設定する働き**をします。**数学的なイコールとは違います**。
**代入は式**なので、**最後に`;`を付けて文にしないと存在できない**ことに注意しましょう。
構文は以下のようになります。2つ目の挙動は初期化のものとほぼ同じです。

```syntax 代入
変数 `=` 値
変数 `=` `{` 値(opt) `}`
```

型キャスト（型変換）
値にも型が存在しているのですが、値は**型キャスト**をすると**型を変更できます**。
型を変更する、ということは、**その値の扱い方が変わる**という訳です。
上の表で挙げた型は、総じて扱える整数の値の範囲が存在しています。
ですから、**`int`では扱えないが`long long`なら扱える**、ような値もあります。
例えば計算結果がその値なら、**事前に`long long`に型キャスト**すれば正確な値が得られます。

## 整数の内部表現
変数のサイズとは何のことでしょうか。それにはまず、コンピューターでの内部表現を知りましょう。
また、丁度いいので、整数の内部表現についても解説していきます。
正直コードを理解するのに必要は無いので、必要になったら読むのでもいいでしょう。

### ビットとバイト
コンピューターでは、**電気的なOn/Offで1/0を表現し、2進数として**扱っています。
最小となる、その**1/0を表現する単位をビット**、そして**8[bit](ビット)でバイト**と扱われます。
なお、8bitで1Byteとは**決まっているわけでは無く**、そうでない場合も極々稀にあります。

### 変数のサイズ
変数のサイズというのは、即ち**変数が使うビットの量**のことになります。
ただし、ビットは物理的に存在している以上、無限に存在しているわけではありません。
また、変数のサイズは固定されていると何かと便利ですし、効率がよくなります。
以上のことから、**変数にサイズを決める、あるいは決まってしまう**のが普通です。

### 負の数を扱いたくなりました
**負の数を扱いたくなりました**。この時一番簡単に思いつくのは**符号ビットを使う**ことです。
例えば、8bitの整数があった時、`**[0](これ)**000 0000`を符号ビットということにしてみましょう。
符号ビットが**`0`/`1`の時、正/負**とし、**残り7bitは絶対値で表現**してみましょう。
`[0000 0001](1)`に対して、`[1000 0001](-1)`のようになり、**`-127から127`が表現できます**。

### 1の補数表現
符号ビットと絶対値で表す以外にも、**正の数の表現を[ビット反転](各ビットの0と1を逆にする)する方法**もあります。
例えば、上と同じく8bitの整数で、`[0000 0001](1)`をビット反転して`[1111 1110](-1)`といった具合。
これも**やっぱり`-127から127`まで表現でき**、`**[0](これ)**000 0000`は**符号ビットの役割を果たします**。
これは、数学の「補数」という考え方に由来するため、**1の補数表現**と言います。

### ダメなのよ。
上の2つの表現、**実はどっちもダメ**なところがあります。例えば、**`0`が2種類ある**のです。
1つの数値に対して2つ以上表現があると、**一意に表現できていない**ということになるのです。
でも、符号ビットが`1`の時は`0`を表現しない、とすると**表現が1個捨てられて無駄**です。

### 2の補数表現
どうすればいいのか。人類はやっぱり数学に由来して、**2の補数表現**にたどり着きました。
内容としては、**負の数は、1の補数表現に`+1`をした表現**で表すことにしたのです。
つまり、8bitの`-1`なら、`[0000 0001](1)`→`[1111 1110](1の補数の-1)`→`[1111 1111](2の補数の-1)`ということになりました。
これなら、例えば8bitであれば、**`127から-128`までを表せる**のです。

### 何がいいのさ
さて、ここまで斜め読みした人は、**どうしてこんな面倒なことをしたんだろう**と思うでしょう。
実は、2の補数表現は**減算を乗算で処理できる**という真の力を秘めているのです。
`36-12→24`なら、`12`を`-12`にして足すと`[0010 0100](36) + [1111 0100](-12) → [0001 1000](24)`、**あらあら**。
**桁あふれした分は見なかったこと**にして、**2進法で計算すると減算が加算で処理できる**のです。

</main>
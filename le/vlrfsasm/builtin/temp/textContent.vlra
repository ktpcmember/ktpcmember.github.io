
{ht.summary.caption; ; (' (hc.p (' "本章では、Vlrfsasmの文法で予め定められている14個の関数について解説します。なお、出力関数は含めていません。")))}
{ht.size.caption; ; (' (hc.p (' "値の幅を取得する関数は、" (hx.v (' "#")) "です。")))}
{ht.size.argument; ; (' (hc.p (' "この関数の引数は1つのみで、幅を取得したい値を指定します。数値リテラルを指定すれば64が返ってきます。")))}
{ht.size.return; ; (' (hc.p (' "当然返り値にも幅があり、この関数では64ビットに固定されています。ただし、実際に使われるのは下位20ビットのみで、上位44ビットは常に0です。")))}
{ht.concatenate.caption; ; (' (hc.p (' "値を連接する関数は、" (hx.v (' "'")) "です。")))}
{ht.concatenate.usage; ; (' (hc.p (' "この関数の引数は、1つ以上ならいくつでもよいです。左側の引数が上位になるように連接され、返り値の幅は各引数の幅の和です。文字コードが同じ文字列ならば、この関数で繋げて1つの文字列にできます。また、構造体を作ることもできます。")))}
{ht.range.caption; ; (' (hc.p (' "幅を読み取る関数があれば、変更する関数もあります。")))}
{ht.range.argument; ; (' (hc.p (' "以下の3関数の引数は共通で、第一引数に対象の値、第二引数に幅を指定します。第二引数は、幅が20ビットに満たない場合、上位に0をつけて拡張されます。また、" (hx.m (' (hx.1 (' "2") (' "19")) "=524288")) "を超える場合は、524288と解釈されます。")))}
{ht.range.resize; ; (' (hc.p (' "関数" (hx.v (' ":")) "は、第一引数について、幅を第二引数に変えて返します。つまり、第一引数の幅が第二引数より小さいときは、上位に必要なだけ0を付け足して返します。一方、大きいときは、上位のビットを削って返します。等しいときは第一引数がそのまま返ってきます。")))}
{ht.range.leftShift; ; (' (hc.p (' "関数" (hx.v (' "&lt;")) "は、第一引数の下位に、第二引数ビットの0を付け足します。")))}
{ht.range.rightShift; ; (' (hc.p (' "関数" (hx.v (' "&gt;")) "は、第一引数の下位から第二引数ビットを削り、残りを返します。なお、第一引数の幅が第二引数以下であるときには、幅0の値を返します。")))}
{ht.calculate.caption; ; (' (hc.p (' "以下の5つの関数は、値の計算を行う関数です。ビット否定関数を除く4つは、1つ以上ならいくつでも引数を取ることができます。返り値の幅は、繰り上がりなどに関わらず常に第一引数の幅と同じです。引数の順番によって結果が変わることに注意してください。また、幅の違う値同士の計算は、最下位を揃えて行われます。第一引数より短い引数があった場合、足りない上位は0として扱われます。")))}
{ht.calculate.not; ; (' (hc.p (' "ビット否定関数" (hx.v (' "!")) "は、Vlrfsasmの組み込み関数で最も単純なものです。引数を1つ取り、全てのビットを反転して返します。返り値の幅は引数の幅と同じです。")))}
{ht.calculate.add; ; (' (hc.p (' "加算関数" (hx.v (' "+")) "は、引数の和を返します。なお、この関数は他の関数や機能を用いて表現することができますが、実行時の計算量を抑えるため、組み込み関数にしています。")))}
{ht.calculate.and; ; (' (hc.p (' "ビット積関数" (hx.v (' "&amp;")) "は、1ビットごとに論理積を取ります。1つでも0があれば結果も0ですから、第二引数以降に第一引数より短いものがないか注意しましょう。")))}
{ht.calculate.or; ; (' (hc.p (' "ビット和関数" (hx.v (' "|")) "は、1ビットごとに論理和を取ります。")))}
{ht.calculate.xor; ; (' (hc.p (' "排他的ビット和関数" (hx.v (' "^")) "は、1ビットごとに排他的論理和を取ります。")))}
{ht.select.caption; ; (' (hc.p (' "選択関数" (hx.v (' "?")) "は、特殊な関数です。構文というべきかもしれません。これは、第一引数に従い、第二引数と第三引数のいずれかを返します。")))}
{ht.select.argument; ; (' (hc.p (' "第一引数は、条件です。第一引数の全てのビットが0であるか、または第一引数の幅が0であるとき、条件は偽です。そうでないとき、つまり1つでも1のビットが含まれるときが真です。第二引数と第三引数にはどんな値でもちょうど1つずつを指定できます。どの引数も省略してはいけません。")))}
{ht.select.action; ; (' (hc.p (' "条件が真と判断された場合、第二引数の値を計算して返します。偽であれば第三引数を実行して返します。この順序が選択関数の特殊な点で、遅延評価を行います。Vlrfsasmはここ以外では正格評価を行い、引数を計算してから関数を実行します。しかし、選択関数は条件分岐の役割を持つので、遅延評価とすることで再帰を使えるようにしています。")))}
{ht.error.caption; ; (' (hc.p (' "エラー関数" (hx.v (' "~")) "も特殊な関数です。これは最早関数ですらありません。値を返さないどころか、Vlrfsasmの実行をそこで止めてしまいます。引数の値は文字列で、ログの最下部に出力されます。")))}
{ht.error.code; ; (' (hc.p (' "引数に文字列リテラルを直接指定することはできません。これは実装時に面倒に思った結果、UTF-16LEで解釈する仕様だからです。次章で解決策を説明します。")))}
{ht.other.caption; ; (' (hc.p (' "さて、律儀に数えた人は、本章でさらに2関数の説明があるものと思うでしょう。それらの名前は" (hx.v (' "@")) "と" (hx.v (' "`")) "です。しかし、中身はまだ実装されていません。関数定義時に名前が被らないように気をつけてください。")))}
{ht.other.reason; ; (' (hc.p (' "これらは、アセンブラとして使うためのラベルを扱う関数もどきと関数なのですが、本HPには必要ないので、後回しにされ続けています。かわいそうですね。")))}